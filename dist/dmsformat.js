'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @type {{degrees: string, minutes: string, seconds: string}}
 */
var UNITS = {
  degrees: '°',
  minutes: '′',
  seconds: '″'
};

/**
 * @type {{PARSE_STRING: string}}
 */
var ERRORS = {
  PARSE_STRING: 'Could not parse string'
};

/**
 * @type {{-: number, N: number, S: number, E: number, W: number}}
 */
var SIGN_INDEX = {
  '-': -1,
  'N': 1,
  'S': -1,
  'E': 1,
  'W': -1
};

/**
 * See https://regex101.com/r/kS2zR1/3
 * @type {RegExp}
 */
var DMS_REGREX = /([NSEW])?(-)?(\d+(?:\.\d+)?)[°º:d\s]?\s?(?:(\d+(?:\.\d+)?)['’‘′:]\s?(?:(\d{1,2}(?:\.\d+)?)(?:"|″|’’|'')?)?)?\s?([NSEW])?/i;

/**
 * Check if the given value is within the allowed range
 * @param {number} value
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
function inRange(value, a, b) {
  return value >= a && value <= b;
}

/**
 * Checks if the given value is of type number
 * @param {*} v
 * @returns {boolean}
 */
function isNumber(v) {
  return typeof v == 'number' && !isNaN(v);
}

/**
 * Extract the decimal value and the orientation from a given match clause.
 * @param {*} m
 * @returns {number}
 * @throws
 */
function decDegFromMatch(m) {
  var sign = SIGN_INDEX[m[2]] || SIGN_INDEX[m[1]] || SIGN_INDEX[m[6]] || 1;
  var degrees = Number(m[3]);
  var minutes = m[4] ? Number(m[4]) : 0;
  var seconds = m[5] ? Number(m[5]) : 0;

  if (!inRange(degrees, 0, 180)) {
    throw new Error('Degrees out of range');
  }

  if (!inRange(minutes, 0, 60)) {
    throw new Error('Minutes out of range');
  }

  if (!inRange(seconds, 0, 60)) {
    throw new Error('Seconds out of range');
  }

  return sign * (degrees + minutes / 60 + seconds / 3600);
}

/**
 * Computes a configuration of the coordinate.
 * @param {[number, number]} coordinate
 * @returns {{}}
 */
function computeCoordinateConfig(coordinate) {
  function computeFor(initValue) {
    var values = {};
    values.initValue = initValue;
    values.degrees = Math.abs(initValue);
    values.degreesInt = Math.floor(values.degrees);
    values.degreesFrac = values.degrees - values.degreesInt;
    values.secondsTotal = 3600 * values.degreesFrac;
    values.minutes = values.secondsTotal / 60;
    values.minutesInt = Math.floor(values.minutes);
    values.seconds = values.secondsTotal - values.minutesInt * 60;
    return values;
  }

  return {
    north: coordinate[1] > 0,
    east: coordinate[0] > 0,
    latValues: computeFor([coordinate[1]]),
    lonValues: computeFor([coordinate[0]])
  };
}

/**
 * Converts grad and decimal minutes to a [lon, lat] coordinate. The function expects coordinates
 * to be in the form `41 24.2028, -2 10.4418` (lat, lon - order) and a comma as an seperator
 *
 * @param {string} value
 * @returns {[number,number]} [lon, lat]
 * @throws
 */
function fromGDM(value) {
  function errorFn(errorMsg) {
    throw new Error(errorMsg);
  }
  var seperator = ',';
  var v = value.trim();

  // check if seperator exists
  if (v.indexOf(seperator) === -1) {
    return errorFn(ERRORS.PARSE_STRING);
  }

  var parts = v.split(',');
  if (parts.length !== 2) {
    return errorFn(ERRORS.PARSE_STRING);
  }

  // try to parse lat coordinate
  var orientationLat = parts[0].trim().substring(0, 1) === '-' ? -1 : 1;
  var partsLat = parts[0].trim().split(' ');
  var decimalGradLat = orientationLat === -1 ? parseFloat(partsLat[0].replace('-', '')) : parseFloat(partsLat[0]);
  var decimalMinutesLat = partsLat.length > 1 ? parseFloat(partsLat[1]) : 0;
  var valueLat = isNumber(decimalGradLat) && isNumber(decimalMinutesLat) ? orientationLat * (decimalGradLat + decimalMinutesLat / 60) : undefined;

  // try to parse lon coordinate
  var orientationLon = parts[1].trim().substring(0, 1) === '-' ? -1 : 1;
  var partsLon = parts[1].trim().split(' ');
  var decimalGradLon = orientationLon === -1 ? parseFloat(partsLon[0].replace('-', '')) : parseFloat(partsLon[0]);
  var decimalMinutesLon = partsLon.length > 1 ? parseFloat(partsLon[1]) : 0;
  var valueLon = isNumber(decimalGradLon) && isNumber(decimalMinutesLon) ? orientationLon * (decimalGradLon + decimalMinutesLon / 60) : undefined;

  if (!isNumber(valueLon) || !isNumber(valueLat)) {
    return errorFn(ERRORS.PARSE_STRING);
  }
  if (!inRange(valueLon, -180, 180) || !inRange(valueLat, -90, 90)) {
    return errorFn('Lon/Lat values out of range');
  }

  return [valueLon, valueLat];
}

/**
 * Function always expect that we got a dms string with the first part describing latitude and
 * the second part describing the longitude
 * @param {string} value
 * @returns {[number,number]} [lon, lat]
 * @throws
 */
function fromDMS(value) {
  var v = value.trim();
  var matchLat = v.match(DMS_REGREX);

  if (!matchLat) {
    throw new Error(ERRORS.PARSE_STRING);
  }

  // If dmsString starts with a hemisphere letter, then the regex can also capture the
  // hemisphere letter for the second coordinate pair if also in the string
  var lonString = matchLat[1] !== undefined ? v.substr(matchLat[0].length - 1).trim() : v.substr(matchLat[0].length).trim();
  var matchLon = lonString.match(DMS_REGREX);

  if (!matchLon) {
    throw new Error(ERRORS.PARSE_STRING);
  }

  return [decDegFromMatch(matchLon), decDegFromMatch(matchLat)];
}

/**
 * Returns a dms string for a given coordinate
 * @param {[number, number]} coordinate [lon, lat]
 * @param {string} optFormatStr e.g.: 'DD MM ss X', 'DD mm X', 'dd X'
 * @param {{ latLonSeparator: string, decimalPlaces: number }} optOptions
 * @returns {string}
 */
function toDMS(coordinate, optFormatStr, optOptions) {
  if (coordinate.length !== 2) {
    throw new Error('Not a valid coordinate');
  }

  var format = optFormatStr !== undefined ? optFormatStr : 'DD MM ss X';
  var options = Object.assign({
    decimalPlaces: 5,
    latLonSeparator: ' '
  }, optOptions !== undefined ? optOptions : {});
  var coordConf = computeCoordinateConfig(coordinate);

  var lat = formatFor(format, options, coordConf.latValues, coordConf.north ? 'N' : 'S');
  var lon = formatFor(format, options, coordConf.lonValues, coordConf.east ? 'E' : 'W');

  function formatFor(format, options, values, X) {
    var formatted = format;
    formatted = formatted.replace(/DD/g, values.degreesInt + UNITS.degrees);
    formatted = formatted.replace(/dd/g, values.degrees.toFixed(options.decimalPlaces) + UNITS.degrees);
    formatted = formatted.replace(/D/g, values.degreesInt);
    formatted = formatted.replace(/d/g, values.degrees.toFixed(options.decimalPlaces));
    formatted = formatted.replace(/MM/g, values.minutesInt + UNITS.minutes);
    formatted = formatted.replace(/mm/g, values.minutes.toFixed(options.decimalPlaces) + UNITS.minutes);
    formatted = formatted.replace(/M/g, values.minutesInt);
    formatted = formatted.replace(/m/g, values.minutes.toFixed(options.decimalPlaces));
    formatted = formatted.replace(/ss/g, values.seconds.toFixed(options.decimalPlaces) + UNITS.seconds);
    formatted = formatted.replace(/s/g, values.seconds.toFixed(options.decimalPlaces));
    formatted = formatted.replace(/-/g, values.initValue < 0 ? '-' : '');
    formatted = formatted.replace(/X/g, X);

    return formatted;
  }

  return lat + options.latLonSeparator + lon;
}

exports.fromGDM = fromGDM;
exports.fromDMS = fromDMS;
exports.toDMS = toDMS;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG1zZm9ybWF0LmpzIiwic291cmNlcyI6WyIuLi9zcmMvZG1zZm9ybWF0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGUge3tkZWdyZWVzOiBzdHJpbmcsIG1pbnV0ZXM6IHN0cmluZywgc2Vjb25kczogc3RyaW5nfX1cbiAqL1xuY29uc3QgVU5JVFMgPSB7XG4gIGRlZ3JlZXM6ICfCsCcsXG4gIG1pbnV0ZXM6ICfigLInLFxuICBzZWNvbmRzOiAn4oCzJyxcbn07XG5cbi8qKlxuICogQHR5cGUge3tQQVJTRV9TVFJJTkc6IHN0cmluZ319XG4gKi9cbmNvbnN0IEVSUk9SUyA9IHtcbiAgUEFSU0VfU1RSSU5HOiAnQ291bGQgbm90IHBhcnNlIHN0cmluZycsXG59O1xuXG4vKipcbiAqIEB0eXBlIHt7LTogbnVtYmVyLCBOOiBudW1iZXIsIFM6IG51bWJlciwgRTogbnVtYmVyLCBXOiBudW1iZXJ9fVxuICovXG5jb25zdCBTSUdOX0lOREVYID0ge1xuICAnLSc6IC0xLFxuICAnTic6IDEsXG4gICdTJzogLTEsXG4gICdFJzogMSxcbiAgJ1cnOiAtMVxufTtcblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9yZWdleDEwMS5jb20vci9rUzJ6UjEvM1xuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgRE1TX1JFR1JFWCA9IC8oW05TRVddKT8oLSk/KFxcZCsoPzpcXC5cXGQrKT8pW8Kwwro6ZFxcc10/XFxzPyg/OihcXGQrKD86XFwuXFxkKyk/KVsn4oCZ4oCY4oCyOl1cXHM/KD86KFxcZHsxLDJ9KD86XFwuXFxkKyk/KSg/OlwifOKAs3zigJnigJl8JycpPyk/KT9cXHM/KFtOU0VXXSk/L2k7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHdpdGhpbiB0aGUgYWxsb3dlZCByYW5nZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpblJhbmdlKHZhbHVlLCBhLCBiKSB7XG4gIHJldHVybiB2YWx1ZSA+PSBhICYmIHZhbHVlIDw9IGI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiB0eXBlIG51bWJlclxuICogQHBhcmFtIHsqfSB2XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT0gJ251bWJlcicgJiYgIWlzTmFOKHYpO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIGRlY2ltYWwgdmFsdWUgYW5kIHRoZSBvcmllbnRhdGlvbiBmcm9tIGEgZ2l2ZW4gbWF0Y2ggY2xhdXNlLlxuICogQHBhcmFtIHsqfSBtXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogQHRocm93c1xuICovXG5mdW5jdGlvbiBkZWNEZWdGcm9tTWF0Y2gobSkge1xuICBjb25zdCBzaWduID0gU0lHTl9JTkRFWFttWzJdXSB8fCBTSUdOX0lOREVYW21bMV1dIHx8IFNJR05fSU5ERVhbbVs2XV0gfHwgMTtcbiAgY29uc3QgZGVncmVlcyA9IE51bWJlcihtWzNdKTtcbiAgY29uc3QgbWludXRlcyA9IG1bNF0gPyBOdW1iZXIobVs0XSkgOiAwO1xuICBjb25zdCBzZWNvbmRzID0gbVs1XSA/IE51bWJlcihtWzVdKSA6IDA7XG5cbiAgaWYgKCFpblJhbmdlKGRlZ3JlZXMsIDAsIDE4MCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZ3JlZXMgb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBpZiAoIWluUmFuZ2UobWludXRlcywgMCwgNjApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaW51dGVzIG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgaWYgKCFpblJhbmdlKHNlY29uZHMsIDAsIDYwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2Vjb25kcyBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogKGRlZ3JlZXMgKyBtaW51dGVzIC8gNjAgKyBzZWNvbmRzIC8gMzYwMCk7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYSBjb25maWd1cmF0aW9uIG9mIHRoZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBjb29yZGluYXRlXG4gKiBAcmV0dXJucyB7e319XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZGluYXRlQ29uZmlnKGNvb3JkaW5hdGUpIHtcbiAgZnVuY3Rpb24gY29tcHV0ZUZvcihpbml0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICB2YWx1ZXMuaW5pdFZhbHVlID0gaW5pdFZhbHVlO1xuICAgIHZhbHVlcy5kZWdyZWVzID0gTWF0aC5hYnMoaW5pdFZhbHVlKTtcbiAgICB2YWx1ZXMuZGVncmVlc0ludCA9IE1hdGguZmxvb3IodmFsdWVzLmRlZ3JlZXMpO1xuICAgIHZhbHVlcy5kZWdyZWVzRnJhYyA9IHZhbHVlcy5kZWdyZWVzIC0gdmFsdWVzLmRlZ3JlZXNJbnQ7XG4gICAgdmFsdWVzLnNlY29uZHNUb3RhbCA9IDM2MDAgKiB2YWx1ZXMuZGVncmVlc0ZyYWM7XG4gICAgdmFsdWVzLm1pbnV0ZXMgPSB2YWx1ZXMuc2Vjb25kc1RvdGFsIC8gNjA7XG4gICAgdmFsdWVzLm1pbnV0ZXNJbnQgPSBNYXRoLmZsb29yKHZhbHVlcy5taW51dGVzKTtcbiAgICB2YWx1ZXMuc2Vjb25kcyA9IHZhbHVlcy5zZWNvbmRzVG90YWwgLSAodmFsdWVzLm1pbnV0ZXNJbnQgKiA2MCk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9ydGg6IGNvb3JkaW5hdGVbMV0gPiAwLFxuICAgIGVhc3Q6IGNvb3JkaW5hdGVbMF0gPiAwLFxuICAgIGxhdFZhbHVlczogY29tcHV0ZUZvcihbY29vcmRpbmF0ZVsxXV0pLFxuICAgIGxvblZhbHVlczogY29tcHV0ZUZvcihbY29vcmRpbmF0ZVswXV0pLFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGdyYWQgYW5kIGRlY2ltYWwgbWludXRlcyB0byBhIFtsb24sIGxhdF0gY29vcmRpbmF0ZS4gVGhlIGZ1bmN0aW9uIGV4cGVjdHMgY29vcmRpbmF0ZXNcbiAqIHRvIGJlIGluIHRoZSBmb3JtIGA0MSAyNC4yMDI4LCAtMiAxMC40NDE4YCAobGF0LCBsb24gLSBvcmRlcikgYW5kIGEgY29tbWEgYXMgYW4gc2VwZXJhdG9yXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7W251bWJlcixudW1iZXJdfSBbbG9uLCBsYXRdXG4gKiBAdGhyb3dzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tR0RNKHZhbHVlKSB7XG4gIGZ1bmN0aW9uIGVycm9yRm4oZXJyb3JNc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICB9XG4gIGNvbnN0IHNlcGVyYXRvciA9ICcsJztcbiAgY29uc3QgdiA9IHZhbHVlLnRyaW0oKTtcblxuICAvLyBjaGVjayBpZiBzZXBlcmF0b3IgZXhpc3RzXG4gIGlmICh2LmluZGV4T2Yoc2VwZXJhdG9yKSA9PT0gLTEpIHsgcmV0dXJuIGVycm9yRm4oRVJST1JTLlBBUlNFX1NUUklORyk7IH1cblxuICBjb25zdCBwYXJ0cyA9IHYuc3BsaXQoJywnKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikgeyByZXR1cm4gZXJyb3JGbihFUlJPUlMuUEFSU0VfU1RSSU5HKTsgfVxuXG4gIC8vIHRyeSB0byBwYXJzZSBsYXQgY29vcmRpbmF0ZVxuICBjb25zdCBvcmllbnRhdGlvbkxhdCA9IHBhcnRzWzBdLnRyaW0oKS5zdWJzdHJpbmcoMCwgMSkgPT09ICctJyA/IC0xIDogMTtcbiAgY29uc3QgcGFydHNMYXQgPSBwYXJ0c1swXS50cmltKCkuc3BsaXQoJyAnKTtcbiAgY29uc3QgZGVjaW1hbEdyYWRMYXQgPSBvcmllbnRhdGlvbkxhdCA9PT0gLTEgPyBwYXJzZUZsb2F0KHBhcnRzTGF0WzBdLnJlcGxhY2UoJy0nLCAnJykpIDogcGFyc2VGbG9hdChwYXJ0c0xhdFswXSk7XG4gIGNvbnN0IGRlY2ltYWxNaW51dGVzTGF0ID0gcGFydHNMYXQubGVuZ3RoID4gMSA/IHBhcnNlRmxvYXQocGFydHNMYXRbMV0pIDogMDtcbiAgY29uc3QgdmFsdWVMYXQgPSBpc051bWJlcihkZWNpbWFsR3JhZExhdCkgJiYgaXNOdW1iZXIoZGVjaW1hbE1pbnV0ZXNMYXQpXG4gICAgPyBvcmllbnRhdGlvbkxhdCAqIChkZWNpbWFsR3JhZExhdCArIGRlY2ltYWxNaW51dGVzTGF0IC8gNjApXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgLy8gdHJ5IHRvIHBhcnNlIGxvbiBjb29yZGluYXRlXG4gIGNvbnN0IG9yaWVudGF0aW9uTG9uID0gcGFydHNbMV0udHJpbSgpLnN1YnN0cmluZygwLCAxKSA9PT0gJy0nID8gLTEgOiAxO1xuICBjb25zdCBwYXJ0c0xvbiA9IHBhcnRzWzFdLnRyaW0oKS5zcGxpdCgnICcpO1xuICBjb25zdCBkZWNpbWFsR3JhZExvbiA9IG9yaWVudGF0aW9uTG9uID09PSAtMSA/IHBhcnNlRmxvYXQocGFydHNMb25bMF0ucmVwbGFjZSgnLScsICcnKSkgOiBwYXJzZUZsb2F0KHBhcnRzTG9uWzBdKTtcbiAgY29uc3QgZGVjaW1hbE1pbnV0ZXNMb24gPSBwYXJ0c0xvbi5sZW5ndGggPiAxID8gcGFyc2VGbG9hdChwYXJ0c0xvblsxXSkgOiAwO1xuICBjb25zdCB2YWx1ZUxvbiA9IGlzTnVtYmVyKGRlY2ltYWxHcmFkTG9uKSAmJiBpc051bWJlcihkZWNpbWFsTWludXRlc0xvbilcbiAgICA/IG9yaWVudGF0aW9uTG9uICogKGRlY2ltYWxHcmFkTG9uICsgZGVjaW1hbE1pbnV0ZXNMb24gLyA2MClcbiAgICA6IHVuZGVmaW5lZDtcblxuICBpZiAoIWlzTnVtYmVyKHZhbHVlTG9uKSB8fCAhaXNOdW1iZXIodmFsdWVMYXQpKSB7IHJldHVybiBlcnJvckZuKEVSUk9SUy5QQVJTRV9TVFJJTkcpOyB9XG4gIGlmICghaW5SYW5nZSh2YWx1ZUxvbiwgLTE4MCwgMTgwKSB8fCAhaW5SYW5nZSh2YWx1ZUxhdCwgLTkwLCA5MCkpIHsgcmV0dXJuIGVycm9yRm4oJ0xvbi9MYXQgdmFsdWVzIG91dCBvZiByYW5nZScpOyB9XG5cbiAgcmV0dXJuIFt2YWx1ZUxvbiwgdmFsdWVMYXRdO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGFsd2F5cyBleHBlY3QgdGhhdCB3ZSBnb3QgYSBkbXMgc3RyaW5nIHdpdGggdGhlIGZpcnN0IHBhcnQgZGVzY3JpYmluZyBsYXRpdHVkZSBhbmRcbiAqIHRoZSBzZWNvbmQgcGFydCBkZXNjcmliaW5nIHRoZSBsb25naXR1ZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1tudW1iZXIsbnVtYmVyXX0gW2xvbiwgbGF0XVxuICogQHRocm93c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURNUyh2YWx1ZSkge1xuICBjb25zdCB2ID0gdmFsdWUudHJpbSgpO1xuICBjb25zdCBtYXRjaExhdCA9IHYubWF0Y2goRE1TX1JFR1JFWCk7XG5cbiAgaWYgKCFtYXRjaExhdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuUEFSU0VfU1RSSU5HKTtcbiAgfVxuXG4gIC8vIElmIGRtc1N0cmluZyBzdGFydHMgd2l0aCBhIGhlbWlzcGhlcmUgbGV0dGVyLCB0aGVuIHRoZSByZWdleCBjYW4gYWxzbyBjYXB0dXJlIHRoZVxuICAvLyBoZW1pc3BoZXJlIGxldHRlciBmb3IgdGhlIHNlY29uZCBjb29yZGluYXRlIHBhaXIgaWYgYWxzbyBpbiB0aGUgc3RyaW5nXG4gIGNvbnN0IGxvblN0cmluZyA9IG1hdGNoTGF0WzFdICE9PSB1bmRlZmluZWRcbiAgICA/IHYuc3Vic3RyKG1hdGNoTGF0WzBdLmxlbmd0aCAtIDEpLnRyaW0oKVxuICAgIDogdi5zdWJzdHIobWF0Y2hMYXRbMF0ubGVuZ3RoKS50cmltKCk7XG4gIGNvbnN0IG1hdGNoTG9uID0gbG9uU3RyaW5nLm1hdGNoKERNU19SRUdSRVgpO1xuXG4gIGlmICghbWF0Y2hMb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLlBBUlNFX1NUUklORyk7XG4gIH1cblxuICByZXR1cm4gW2RlY0RlZ0Zyb21NYXRjaChtYXRjaExvbiksIGRlY0RlZ0Zyb21NYXRjaChtYXRjaExhdCldO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhIGRtcyBzdHJpbmcgZm9yIGEgZ2l2ZW4gY29vcmRpbmF0ZVxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBjb29yZGluYXRlIFtsb24sIGxhdF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRGb3JtYXRTdHIgZS5nLjogJ0REIE1NIHNzIFgnLCAnREQgbW0gWCcsICdkZCBYJ1xuICogQHBhcmFtIHt7IGxhdExvblNlcGFyYXRvcjogc3RyaW5nLCBkZWNpbWFsUGxhY2VzOiBudW1iZXIgfX0gb3B0T3B0aW9uc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRE1TKGNvb3JkaW5hdGUsIG9wdEZvcm1hdFN0ciwgb3B0T3B0aW9ucykge1xuICBpZiAoY29vcmRpbmF0ZS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGNvb3JkaW5hdGUnKTtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdCA9IG9wdEZvcm1hdFN0ciAhPT0gdW5kZWZpbmVkXG4gICAgPyBvcHRGb3JtYXRTdHJcbiAgICA6ICdERCBNTSBzcyBYJztcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGRlY2ltYWxQbGFjZXM6IDUsXG4gICAgbGF0TG9uU2VwYXJhdG9yOiAnICdcbiAgfSwgb3B0T3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0T3B0aW9ucyA6IHt9KTtcbiAgY29uc3QgY29vcmRDb25mID0gY29tcHV0ZUNvb3JkaW5hdGVDb25maWcoY29vcmRpbmF0ZSk7XG5cbiAgY29uc3QgbGF0ID0gZm9ybWF0Rm9yKGZvcm1hdCwgb3B0aW9ucywgY29vcmRDb25mLmxhdFZhbHVlcywgKGNvb3JkQ29uZi5ub3J0aCkgPyAnTicgOiAnUycgKTtcbiAgY29uc3QgbG9uID0gZm9ybWF0Rm9yKGZvcm1hdCwgb3B0aW9ucywgY29vcmRDb25mLmxvblZhbHVlcywgKGNvb3JkQ29uZi5lYXN0KSA/ICdFJyA6ICdXJyApO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdEZvcihmb3JtYXQsIG9wdGlvbnMsIHZhbHVlcywgWCkge1xuICAgIHZhciBmb3JtYXR0ZWQgPSBmb3JtYXQ7XG4gICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoL0REL2csIHZhbHVlcy5kZWdyZWVzSW50K1VOSVRTLmRlZ3JlZXMpO1xuICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9kZC9nLCB2YWx1ZXMuZGVncmVlcy50b0ZpeGVkKG9wdGlvbnMuZGVjaW1hbFBsYWNlcykrVU5JVFMuZGVncmVlcyk7XG4gICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoL0QvZywgdmFsdWVzLmRlZ3JlZXNJbnQpO1xuICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9kL2csIHZhbHVlcy5kZWdyZWVzLnRvRml4ZWQob3B0aW9ucy5kZWNpbWFsUGxhY2VzKSk7XG4gICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoL01NL2csIHZhbHVlcy5taW51dGVzSW50K1VOSVRTLm1pbnV0ZXMpO1xuICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9tbS9nLCB2YWx1ZXMubWludXRlcy50b0ZpeGVkKG9wdGlvbnMuZGVjaW1hbFBsYWNlcykrVU5JVFMubWludXRlcyk7XG4gICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoL00vZywgdmFsdWVzLm1pbnV0ZXNJbnQpO1xuICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9tL2csIHZhbHVlcy5taW51dGVzLnRvRml4ZWQob3B0aW9ucy5kZWNpbWFsUGxhY2VzKSk7XG4gICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoL3NzL2csIHZhbHVlcy5zZWNvbmRzLnRvRml4ZWQob3B0aW9ucy5kZWNpbWFsUGxhY2VzKStVTklUUy5zZWNvbmRzKTtcbiAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZSgvcy9nLCB2YWx1ZXMuc2Vjb25kcy50b0ZpeGVkKG9wdGlvbnMuZGVjaW1hbFBsYWNlcykpO1xuICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC8tL2csICh2YWx1ZXMuaW5pdFZhbHVlPDApID8gJy0nIDogJycpO1xuICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9YL2csIFgpO1xuXG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgfVxuXG4gIHJldHVybiBsYXQgKyBvcHRpb25zLmxhdExvblNlcGFyYXRvciArIGxvbjtcbn1cbiJdLCJuYW1lcyI6WyJVTklUUyIsIkVSUk9SUyIsIlNJR05fSU5ERVgiLCJETVNfUkVHUkVYIiwiaW5SYW5nZSIsInZhbHVlIiwiYSIsImIiLCJpc051bWJlciIsInYiLCJpc05hTiIsImRlY0RlZ0Zyb21NYXRjaCIsIm0iLCJzaWduIiwiZGVncmVlcyIsIk51bWJlciIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwiRXJyb3IiLCJjb21wdXRlQ29vcmRpbmF0ZUNvbmZpZyIsImNvb3JkaW5hdGUiLCJjb21wdXRlRm9yIiwiaW5pdFZhbHVlIiwidmFsdWVzIiwiTWF0aCIsImFicyIsImRlZ3JlZXNJbnQiLCJmbG9vciIsImRlZ3JlZXNGcmFjIiwic2Vjb25kc1RvdGFsIiwibWludXRlc0ludCIsImZyb21HRE0iLCJlcnJvckZuIiwiZXJyb3JNc2ciLCJzZXBlcmF0b3IiLCJ0cmltIiwiaW5kZXhPZiIsIlBBUlNFX1NUUklORyIsInBhcnRzIiwic3BsaXQiLCJsZW5ndGgiLCJvcmllbnRhdGlvbkxhdCIsInN1YnN0cmluZyIsInBhcnRzTGF0IiwiZGVjaW1hbEdyYWRMYXQiLCJwYXJzZUZsb2F0IiwicmVwbGFjZSIsImRlY2ltYWxNaW51dGVzTGF0IiwidmFsdWVMYXQiLCJ1bmRlZmluZWQiLCJvcmllbnRhdGlvbkxvbiIsInBhcnRzTG9uIiwiZGVjaW1hbEdyYWRMb24iLCJkZWNpbWFsTWludXRlc0xvbiIsInZhbHVlTG9uIiwiZnJvbURNUyIsIm1hdGNoTGF0IiwibWF0Y2giLCJsb25TdHJpbmciLCJzdWJzdHIiLCJtYXRjaExvbiIsInRvRE1TIiwib3B0Rm9ybWF0U3RyIiwib3B0T3B0aW9ucyIsImZvcm1hdCIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJjb29yZENvbmYiLCJsYXQiLCJmb3JtYXRGb3IiLCJsYXRWYWx1ZXMiLCJub3J0aCIsImxvbiIsImxvblZhbHVlcyIsImVhc3QiLCJYIiwiZm9ybWF0dGVkIiwidG9GaXhlZCIsImRlY2ltYWxQbGFjZXMiLCJsYXRMb25TZXBhcmF0b3IiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0FBR0EsSUFBTUEsUUFBUTtXQUNILEdBREc7V0FFSCxHQUZHO1dBR0g7Q0FIWDs7Ozs7QUFTQSxJQUFNQyxTQUFTO2dCQUNDO0NBRGhCOzs7OztBQU9BLElBQU1DLGFBQWE7T0FDWixDQUFDLENBRFc7T0FFWixDQUZZO09BR1osQ0FBQyxDQUhXO09BSVosQ0FKWTtPQUtaLENBQUM7Q0FMUjs7Ozs7O0FBWUEsSUFBTUMsYUFBYSwySEFBbkI7Ozs7Ozs7OztBQVNBLFNBQVNDLE9BQVQsQ0FBaUJDLEtBQWpCLEVBQXdCQyxDQUF4QixFQUEyQkMsQ0FBM0IsRUFBOEI7U0FDckJGLFNBQVNDLENBQVQsSUFBY0QsU0FBU0UsQ0FBOUI7Ozs7Ozs7O0FBUUYsU0FBU0MsUUFBVCxDQUFrQkMsQ0FBbEIsRUFBcUI7U0FDWixPQUFPQSxDQUFQLElBQVksUUFBWixJQUF3QixDQUFDQyxNQUFNRCxDQUFOLENBQWhDOzs7Ozs7Ozs7QUFTRixTQUFTRSxlQUFULENBQXlCQyxDQUF6QixFQUE0QjtNQUNwQkMsT0FBT1gsV0FBV1UsRUFBRSxDQUFGLENBQVgsS0FBb0JWLFdBQVdVLEVBQUUsQ0FBRixDQUFYLENBQXBCLElBQXdDVixXQUFXVSxFQUFFLENBQUYsQ0FBWCxDQUF4QyxJQUE0RCxDQUF6RTtNQUNNRSxVQUFVQyxPQUFPSCxFQUFFLENBQUYsQ0FBUCxDQUFoQjtNQUNNSSxVQUFVSixFQUFFLENBQUYsSUFBT0csT0FBT0gsRUFBRSxDQUFGLENBQVAsQ0FBUCxHQUFzQixDQUF0QztNQUNNSyxVQUFVTCxFQUFFLENBQUYsSUFBT0csT0FBT0gsRUFBRSxDQUFGLENBQVAsQ0FBUCxHQUFzQixDQUF0Qzs7TUFFSSxDQUFDUixRQUFRVSxPQUFSLEVBQWlCLENBQWpCLEVBQW9CLEdBQXBCLENBQUwsRUFBK0I7VUFDdkIsSUFBSUksS0FBSixDQUFVLHNCQUFWLENBQU47OztNQUdFLENBQUNkLFFBQVFZLE9BQVIsRUFBaUIsQ0FBakIsRUFBb0IsRUFBcEIsQ0FBTCxFQUE4QjtVQUN0QixJQUFJRSxLQUFKLENBQVUsc0JBQVYsQ0FBTjs7O01BR0UsQ0FBQ2QsUUFBUWEsT0FBUixFQUFpQixDQUFqQixFQUFvQixFQUFwQixDQUFMLEVBQThCO1VBQ3RCLElBQUlDLEtBQUosQ0FBVSxzQkFBVixDQUFOOzs7U0FHS0wsUUFBUUMsVUFBVUUsVUFBVSxFQUFwQixHQUF5QkMsVUFBVSxJQUEzQyxDQUFQOzs7Ozs7OztBQVFGLFNBQVNFLHVCQUFULENBQWlDQyxVQUFqQyxFQUE2QztXQUNsQ0MsVUFBVCxDQUFvQkMsU0FBcEIsRUFBK0I7UUFDdkJDLFNBQVMsRUFBZjtXQUNPRCxTQUFQLEdBQW1CQSxTQUFuQjtXQUNPUixPQUFQLEdBQWlCVSxLQUFLQyxHQUFMLENBQVNILFNBQVQsQ0FBakI7V0FDT0ksVUFBUCxHQUFvQkYsS0FBS0csS0FBTCxDQUFXSixPQUFPVCxPQUFsQixDQUFwQjtXQUNPYyxXQUFQLEdBQXFCTCxPQUFPVCxPQUFQLEdBQWlCUyxPQUFPRyxVQUE3QztXQUNPRyxZQUFQLEdBQXNCLE9BQU9OLE9BQU9LLFdBQXBDO1dBQ09aLE9BQVAsR0FBaUJPLE9BQU9NLFlBQVAsR0FBc0IsRUFBdkM7V0FDT0MsVUFBUCxHQUFvQk4sS0FBS0csS0FBTCxDQUFXSixPQUFPUCxPQUFsQixDQUFwQjtXQUNPQyxPQUFQLEdBQWlCTSxPQUFPTSxZQUFQLEdBQXVCTixPQUFPTyxVQUFQLEdBQW9CLEVBQTVEO1dBQ09QLE1BQVA7OztTQUdLO1dBQ0VILFdBQVcsQ0FBWCxJQUFnQixDQURsQjtVQUVDQSxXQUFXLENBQVgsSUFBZ0IsQ0FGakI7ZUFHTUMsV0FBVyxDQUFDRCxXQUFXLENBQVgsQ0FBRCxDQUFYLENBSE47ZUFJTUMsV0FBVyxDQUFDRCxXQUFXLENBQVgsQ0FBRCxDQUFYO0dBSmI7Ozs7Ozs7Ozs7O0FBZ0JGLEFBQU8sU0FBU1csT0FBVCxDQUFpQjFCLEtBQWpCLEVBQXdCO1dBQ3BCMkIsT0FBVCxDQUFpQkMsUUFBakIsRUFBMkI7VUFDbkIsSUFBSWYsS0FBSixDQUFVZSxRQUFWLENBQU47O01BRUlDLFlBQVksR0FBbEI7TUFDTXpCLElBQUlKLE1BQU04QixJQUFOLEVBQVY7OztNQUdJMUIsRUFBRTJCLE9BQUYsQ0FBVUYsU0FBVixNQUF5QixDQUFDLENBQTlCLEVBQWlDO1dBQVNGLFFBQVEvQixPQUFPb0MsWUFBZixDQUFQOzs7TUFFN0JDLFFBQVE3QixFQUFFOEIsS0FBRixDQUFRLEdBQVIsQ0FBZDtNQUNJRCxNQUFNRSxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO1dBQVNSLFFBQVEvQixPQUFPb0MsWUFBZixDQUFQOzs7O01BR3BCSSxpQkFBaUJILE1BQU0sQ0FBTixFQUFTSCxJQUFULEdBQWdCTyxTQUFoQixDQUEwQixDQUExQixFQUE2QixDQUE3QixNQUFvQyxHQUFwQyxHQUEwQyxDQUFDLENBQTNDLEdBQStDLENBQXRFO01BQ01DLFdBQVdMLE1BQU0sQ0FBTixFQUFTSCxJQUFULEdBQWdCSSxLQUFoQixDQUFzQixHQUF0QixDQUFqQjtNQUNNSyxpQkFBaUJILG1CQUFtQixDQUFDLENBQXBCLEdBQXdCSSxXQUFXRixTQUFTLENBQVQsRUFBWUcsT0FBWixDQUFvQixHQUFwQixFQUF5QixFQUF6QixDQUFYLENBQXhCLEdBQW1FRCxXQUFXRixTQUFTLENBQVQsQ0FBWCxDQUExRjtNQUNNSSxvQkFBb0JKLFNBQVNILE1BQVQsR0FBa0IsQ0FBbEIsR0FBc0JLLFdBQVdGLFNBQVMsQ0FBVCxDQUFYLENBQXRCLEdBQWdELENBQTFFO01BQ01LLFdBQVd4QyxTQUFTb0MsY0FBVCxLQUE0QnBDLFNBQVN1QyxpQkFBVCxDQUE1QixHQUNiTixrQkFBa0JHLGlCQUFpQkcsb0JBQW9CLEVBQXZELENBRGEsR0FFYkUsU0FGSjs7O01BS01DLGlCQUFpQlosTUFBTSxDQUFOLEVBQVNILElBQVQsR0FBZ0JPLFNBQWhCLENBQTBCLENBQTFCLEVBQTZCLENBQTdCLE1BQW9DLEdBQXBDLEdBQTBDLENBQUMsQ0FBM0MsR0FBK0MsQ0FBdEU7TUFDTVMsV0FBV2IsTUFBTSxDQUFOLEVBQVNILElBQVQsR0FBZ0JJLEtBQWhCLENBQXNCLEdBQXRCLENBQWpCO01BQ01hLGlCQUFpQkYsbUJBQW1CLENBQUMsQ0FBcEIsR0FBd0JMLFdBQVdNLFNBQVMsQ0FBVCxFQUFZTCxPQUFaLENBQW9CLEdBQXBCLEVBQXlCLEVBQXpCLENBQVgsQ0FBeEIsR0FBbUVELFdBQVdNLFNBQVMsQ0FBVCxDQUFYLENBQTFGO01BQ01FLG9CQUFvQkYsU0FBU1gsTUFBVCxHQUFrQixDQUFsQixHQUFzQkssV0FBV00sU0FBUyxDQUFULENBQVgsQ0FBdEIsR0FBZ0QsQ0FBMUU7TUFDTUcsV0FBVzlDLFNBQVM0QyxjQUFULEtBQTRCNUMsU0FBUzZDLGlCQUFULENBQTVCLEdBQ2JILGtCQUFrQkUsaUJBQWlCQyxvQkFBb0IsRUFBdkQsQ0FEYSxHQUViSixTQUZKOztNQUlJLENBQUN6QyxTQUFTOEMsUUFBVCxDQUFELElBQXVCLENBQUM5QyxTQUFTd0MsUUFBVCxDQUE1QixFQUFnRDtXQUFTaEIsUUFBUS9CLE9BQU9vQyxZQUFmLENBQVA7O01BQzlDLENBQUNqQyxRQUFRa0QsUUFBUixFQUFrQixDQUFDLEdBQW5CLEVBQXdCLEdBQXhCLENBQUQsSUFBaUMsQ0FBQ2xELFFBQVE0QyxRQUFSLEVBQWtCLENBQUMsRUFBbkIsRUFBdUIsRUFBdkIsQ0FBdEMsRUFBa0U7V0FBU2hCLFFBQVEsNkJBQVIsQ0FBUDs7O1NBRTdELENBQUNzQixRQUFELEVBQVdOLFFBQVgsQ0FBUDs7Ozs7Ozs7OztBQVVGLEFBQU8sU0FBU08sT0FBVCxDQUFpQmxELEtBQWpCLEVBQXdCO01BQ3ZCSSxJQUFJSixNQUFNOEIsSUFBTixFQUFWO01BQ01xQixXQUFXL0MsRUFBRWdELEtBQUYsQ0FBUXRELFVBQVIsQ0FBakI7O01BRUksQ0FBQ3FELFFBQUwsRUFBZTtVQUNQLElBQUl0QyxLQUFKLENBQVVqQixPQUFPb0MsWUFBakIsQ0FBTjs7Ozs7TUFLSXFCLFlBQVlGLFNBQVMsQ0FBVCxNQUFnQlAsU0FBaEIsR0FDZHhDLEVBQUVrRCxNQUFGLENBQVNILFNBQVMsQ0FBVCxFQUFZaEIsTUFBWixHQUFxQixDQUE5QixFQUFpQ0wsSUFBakMsRUFEYyxHQUVkMUIsRUFBRWtELE1BQUYsQ0FBU0gsU0FBUyxDQUFULEVBQVloQixNQUFyQixFQUE2QkwsSUFBN0IsRUFGSjtNQUdNeUIsV0FBV0YsVUFBVUQsS0FBVixDQUFnQnRELFVBQWhCLENBQWpCOztNQUVJLENBQUN5RCxRQUFMLEVBQWU7VUFDUCxJQUFJMUMsS0FBSixDQUFVakIsT0FBT29DLFlBQWpCLENBQU47OztTQUdLLENBQUMxQixnQkFBZ0JpRCxRQUFoQixDQUFELEVBQTRCakQsZ0JBQWdCNkMsUUFBaEIsQ0FBNUIsQ0FBUDs7Ozs7Ozs7OztBQVdGLEFBQU8sU0FBU0ssS0FBVCxDQUFlekMsVUFBZixFQUEyQjBDLFlBQTNCLEVBQXlDQyxVQUF6QyxFQUFxRDtNQUN0RDNDLFdBQVdvQixNQUFYLEtBQXNCLENBQTFCLEVBQTZCO1VBQ3JCLElBQUl0QixLQUFKLENBQVUsd0JBQVYsQ0FBTjs7O01BR0k4QyxTQUFTRixpQkFBaUJiLFNBQWpCLEdBQ1hhLFlBRFcsR0FFWCxZQUZKO01BR01HLFVBQVVDLE9BQU9DLE1BQVAsQ0FBYzttQkFDYixDQURhO3FCQUVYO0dBRkgsRUFHYkosZUFBZWQsU0FBZixHQUEyQmMsVUFBM0IsR0FBd0MsRUFIM0IsQ0FBaEI7TUFJTUssWUFBWWpELHdCQUF3QkMsVUFBeEIsQ0FBbEI7O01BRU1pRCxNQUFNQyxVQUFVTixNQUFWLEVBQWtCQyxPQUFsQixFQUEyQkcsVUFBVUcsU0FBckMsRUFBaURILFVBQVVJLEtBQVgsR0FBb0IsR0FBcEIsR0FBMEIsR0FBMUUsQ0FBWjtNQUNNQyxNQUFNSCxVQUFVTixNQUFWLEVBQWtCQyxPQUFsQixFQUEyQkcsVUFBVU0sU0FBckMsRUFBaUROLFVBQVVPLElBQVgsR0FBbUIsR0FBbkIsR0FBeUIsR0FBekUsQ0FBWjs7V0FFU0wsU0FBVCxDQUFtQk4sTUFBbkIsRUFBMkJDLE9BQTNCLEVBQW9DMUMsTUFBcEMsRUFBNENxRCxDQUE1QyxFQUErQztRQUN6Q0MsWUFBWWIsTUFBaEI7Z0JBQ1lhLFVBQVUvQixPQUFWLENBQWtCLEtBQWxCLEVBQXlCdkIsT0FBT0csVUFBUCxHQUFrQjFCLE1BQU1jLE9BQWpELENBQVo7Z0JBQ1krRCxVQUFVL0IsT0FBVixDQUFrQixLQUFsQixFQUF5QnZCLE9BQU9ULE9BQVAsQ0FBZWdFLE9BQWYsQ0FBdUJiLFFBQVFjLGFBQS9CLElBQThDL0UsTUFBTWMsT0FBN0UsQ0FBWjtnQkFDWStELFVBQVUvQixPQUFWLENBQWtCLElBQWxCLEVBQXdCdkIsT0FBT0csVUFBL0IsQ0FBWjtnQkFDWW1ELFVBQVUvQixPQUFWLENBQWtCLElBQWxCLEVBQXdCdkIsT0FBT1QsT0FBUCxDQUFlZ0UsT0FBZixDQUF1QmIsUUFBUWMsYUFBL0IsQ0FBeEIsQ0FBWjtnQkFDWUYsVUFBVS9CLE9BQVYsQ0FBa0IsS0FBbEIsRUFBeUJ2QixPQUFPTyxVQUFQLEdBQWtCOUIsTUFBTWdCLE9BQWpELENBQVo7Z0JBQ1k2RCxVQUFVL0IsT0FBVixDQUFrQixLQUFsQixFQUF5QnZCLE9BQU9QLE9BQVAsQ0FBZThELE9BQWYsQ0FBdUJiLFFBQVFjLGFBQS9CLElBQThDL0UsTUFBTWdCLE9BQTdFLENBQVo7Z0JBQ1k2RCxVQUFVL0IsT0FBVixDQUFrQixJQUFsQixFQUF3QnZCLE9BQU9PLFVBQS9CLENBQVo7Z0JBQ1krQyxVQUFVL0IsT0FBVixDQUFrQixJQUFsQixFQUF3QnZCLE9BQU9QLE9BQVAsQ0FBZThELE9BQWYsQ0FBdUJiLFFBQVFjLGFBQS9CLENBQXhCLENBQVo7Z0JBQ1lGLFVBQVUvQixPQUFWLENBQWtCLEtBQWxCLEVBQXlCdkIsT0FBT04sT0FBUCxDQUFlNkQsT0FBZixDQUF1QmIsUUFBUWMsYUFBL0IsSUFBOEMvRSxNQUFNaUIsT0FBN0UsQ0FBWjtnQkFDWTRELFVBQVUvQixPQUFWLENBQWtCLElBQWxCLEVBQXdCdkIsT0FBT04sT0FBUCxDQUFlNkQsT0FBZixDQUF1QmIsUUFBUWMsYUFBL0IsQ0FBeEIsQ0FBWjtnQkFDWUYsVUFBVS9CLE9BQVYsQ0FBa0IsSUFBbEIsRUFBeUJ2QixPQUFPRCxTQUFQLEdBQWlCLENBQWxCLEdBQXVCLEdBQXZCLEdBQTZCLEVBQXJELENBQVo7Z0JBQ1l1RCxVQUFVL0IsT0FBVixDQUFrQixJQUFsQixFQUF3QjhCLENBQXhCLENBQVo7O1dBRU9DLFNBQVA7OztTQUdLUixNQUFNSixRQUFRZSxlQUFkLEdBQWdDUCxHQUF2Qzs7Ozs7OzsifQ==
